
paste to https://app.code2flow.com/

push_swap;
while (stack_b is not empty || stack_a not sorted)
{
  if(stack_a[top] < median?)
    pb;
  if (stack_b_len >= 2 && stack_a[top] > stack_a[top - 1] && stack_b[top] < stack_b[top - 1]?)
    ss;
  if (stack_a[top] > stack_a[top - 1]?)
    sa;
  else
  {
    if (next value < median in upper half?)
      ra;
    else if (next value < median in lower half?)
      rra;
    else if (same distance to next min value in lower && in upper half?)
      rotate the lowest value of the two to the top of the stack;
  }
  if (no value lower than median in stack_a)
    break ;
}

push_swap;
while (stack_b is not empty || stack_a not sorted || stack_b not sorted)
{

	if (stack_a[bottom] < stack_a[top] && both > median)
		ra;
	else if (stack[bottom] < stack[top])
		rra;
	if (stack_a[top] > stack_a[top - 1]?)
    	sa;
	if (stack_a[top] < median?)
	{
		pb;
		if (stack_b_len >= 2 && stack_b[top] < stack_b[top] - 1)
		{
			if (stack_b[top] < stack_b[bottom])
				rb;
			else if (sa_len >= 2 && stack_a[top] > stack_a[top - 1])
				ss;
			else
				sb;
		}
		continue ;
	}
	if (stack_b_len < median + 1)
	{
		min = get_next_min();
		while (min)
			rra/ra;
		continue ;
	}
	else
	{
		if (stack_b is sorted from bottom to top ascend.)
		{
			if (stack_a is sorted from top to bottom ascend.)
				while (stack_b_size)
					pa;
			else
				sort_stack_a();
		}
		else
		{
			//sort_stack_b()
			while (stack_b not sorted)
			{
				min = get_next_min();
				while (min)
					rra/ra;
				pb;
			}
		}
	}
}

Input test:
2 3 5 12 10 6 9 7 4 1 8 11

median_method(t_stack *stack, size_t median);
{
	while (stack_size(stack_a) > median)
	{
		if (stack_a[top] < median)
			pb;
		else
		{
			if (stack_a[bottom] < median)
			{
				rra;
				pb;
			}
			else
			{
				while (stack_a[top] >= mid)
					ra;
			}
		}
	}
}
median_method(t_stack *stack, size_t median);
{
	while (stack_size(stack_a) > median)
	{
		if (stack_a[top] < median)
			pb;
		if (stack_a[bottom] < median)
		{
			rra;
			continue
		}
		while (stack_a[top] >= median)
			ra;
	}
}

chonk_a;
{
	if (chonk_size_b == 2)
		check_swap();
	if (chonk_size_a == 2)
		check_swap()
	while (chonk_a && chonk_b sorted)
		send_chonk_to_a(); return;
	if (chonk group == 1)
		special_function();
	send_lower_half_to_b
	{
		*chonk check_swap chonk*	// check swap later
		if rra
			while rra
				check push_b		// later check with sid
				check swap_a		// later check with sid
		chonk_b();
	}
	chonk_a();
}

chonk_b;
{
	if (chonk_size_b == 2)
		check_swap(); (return;???)
	if (chonk_size_a == 2)
		check_swap();
	while (chonk_a && chonk_b sorted)
		send_chonk_to_a()
	send_upper_half_to_a
	{
		*chonk check swap chonk*	// check_swap later
		if rrb 
			while rrb
				check push_a*		// later check with sid
				check swap_b*		// later check with sid
		chonk_a();
	}
	chonk_b();
}

special_function;
{

}
